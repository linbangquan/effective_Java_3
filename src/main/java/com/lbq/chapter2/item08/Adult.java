package com.lbq.chapter2.item08;
/**
 * 	避免使用终结方法和清除方法
 * 1.终结方法(finalizer)通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、性能降低，以及可移植性问题。
 * 2.在Java9中用清除方法(cleaner)代替了终结方法。清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢，一般情况下也是不必要的。
 * 3.终结方法和清除方法的缺点在于不能保证会被及时执行。从一个对象变得不可到达开始，到它的终结方法被执行，所花费的时间是任意长的。
 * 4.这意味着，注重时间的任务不应该由终结方法或者清除方法来完成。例如，用终结方法或者清除方法来关闭已经打开的文件，就是一个严重的错误，因为打开文件的描述符是一种很有限的资源。
 * 5.Java语言规范不仅不保证终结方法或者清除方法会被及时地执行，而且根本就不保证它们会被执行。永远不应该依赖终结方法或者清除方法来更新重要的持久状态。
 * 6.不要被System.gc和System.runFinalization这两个方法所诱惑，它们确实增加了终结方法或者清除方法被执行的机会，但是它们并不保证终结方法或者清除方法一定会被执行。
 * 7.如果忽略在终结过程中被抛出来的未被捕获的异常，该对象的终结过程也会终止。
 * 8.未被捕获的异常会使对象处于破坏的状态，如果另一个线程企图使用这种被破坏的对象，则可能发生任何不确定的行为。
 * 9.正常情况下，未被捕获的异常将会使线程终止，并打印出栈轨迹(stack trace)，但是，如果异常发生在终结方法之中，则不会如此，甚至连警告都不会打印出来。
 * 10.清除方法没有这个问题，因为使用清除方法的一个类库在控制它的线程。
 * 11.使用终结方法和清除方法有一个非常严重的性能损失。
 * 12.终结方法有一个严重的安全问题：它们为终结方法攻击打开了类的大门。
 * 13.如果类的对象中封装的资源(例如文件或者线程)确实需要终止，应该怎么做才能不用编写终结方法或者清除方法呢？
 * 	只需让类实现AutoCloseable，并要求其客户端在每个实例不再需要的时候调用close方法，一般是利用try-with-resources确保终止，即使遇到异常也是如此。
 * 	值得提及的一个细节是，该实例必须记录下自己是否已经被关闭了：close方法必须在一个私有域中记录下“该对象已经不再有效”。
 * 	如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，并且抛出IllegalStateException异常。
 * @author 14378
 *
 */
public class Adult {

	public static void main(String[] args) {
//		try(Room myRoom = new Room(7)){
//			System.out.println("Goodbye");
//		}

		new Room(99);
//		System.gc();
		System.out.println("Peace out");
		
	}

}
